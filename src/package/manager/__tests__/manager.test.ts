import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest'
import * as fs from 'fs-extra'
import { join } from 'path'
import { tmpdir } from 'os'

// Mock child_process module before importing the module under test
vi.mock('child_process', () => ({
  execSync: vi.fn(),
}))

// Import after mocking (mocked but available for type checking)
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import { execSync } from 'child_process'
import {
  pmMarkFiles,
  pmInstallCmd,
  pmUpdateCmd,
  pmRunScriptCmd,
  getPackageManager,
  getRunScriptCmd,
  getPackageManagerInstallCmd,
  getPackageManagerUpdateCmd,
  isYarn,
  runPmUpdate,
} from '../pm'

// Mock console.log
const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {})

describe('Package Manager Operations', () => {
  let tempDir: string

  beforeEach(async () => {
    // Create a unique temporary directory for each test
    tempDir = await fs.mkdtemp(join(tmpdir(), 'yalc-test-pm-'))

    // Clear all mocks
    vi.clearAllMocks()
  })

  afterEach(async () => {
    // Clean up temporary directory
    await fs.remove(tempDir)

    // Restore mocks
    consoleSpy.mockRestore()
  })

  describe('package manager detection constants', () => {
    it('should define correct mark files for each package manager', () => {
      expect(pmMarkFiles.pnpm).toEqual(['pnpm-lock.yaml'])
      expect(pmMarkFiles.yarn).toEqual(['yarn.lock'])
      expect(pmMarkFiles.npm).toEqual(['package-lock.json'])
    })

    it('should define correct install commands for each package manager', () => {
      expect(pmInstallCmd.pnpm).toBe('pnpm install')
      expect(pmInstallCmd.yarn).toBe('yarn')
      expect(pmInstallCmd.npm).toBe('npm install')
    })

    it('should define correct update commands for each package manager', () => {
      expect(pmUpdateCmd.pnpm).toBe('pnpm update')
      expect(pmUpdateCmd.yarn).toBe('yarn upgrade')
      expect(pmUpdateCmd.npm).toBe('npm update')
    })

    it('should define correct run script commands for each package manager', () => {
      expect(pmRunScriptCmd.pnpm).toBe('pnpm')
      expect(pmRunScriptCmd.yarn).toBe('yarn')
      expect(pmRunScriptCmd.npm).toBe('npm run')
    })
  })

  describe('getPackageManager', () => {
    it('should return npm as default when no lock files exist', () => {
      const result = getPackageManager(tempDir)
      expect(result).toBe('npm')
    })

    it('should detect pnpm when pnpm-lock.yaml exists', async () => {
      const lockFile = join(tempDir, 'pnpm-lock.yaml')
      await fs.writeFile(lockFile, 'lockfileVersion: 5.4')

      const result = getPackageManager(tempDir)
      expect(result).toBe('pnpm')
    })

    it('should detect yarn when yarn.lock exists', async () => {
      const lockFile = join(tempDir, 'yarn.lock')
      await fs.writeFile(lockFile, '# THIS IS AN AUTOGENERATED FILE.')

      const result = getPackageManager(tempDir)
      expect(result).toBe('yarn')
    })

    it('should detect npm when package-lock.json exists', async () => {
      const lockFile = join(tempDir, 'package-lock.json')
      await fs.writeFile(
        lockFile,
        JSON.stringify({
          name: 'test',
          version: '1.0.0',
          lockfileVersion: 2,
        }),
      )

      const result = getPackageManager(tempDir)
      expect(result).toBe('npm')
    })

    it('should prioritize first detected package manager when multiple lock files exist', async () => {
      // Create multiple lock files - pnpm should be detected first
      await fs.writeFile(
        join(tempDir, 'pnpm-lock.yaml'),
        'lockfileVersion: 5.4',
      )
      await fs.writeFile(join(tempDir, 'yarn.lock'), '# Yarn lock')
      await fs.writeFile(join(tempDir, 'package-lock.json'), '{}')

      const result = getPackageManager(tempDir)
      expect(result).toBe('pnpm')
    })

    it('should handle non-existent directory gracefully', () => {
      const nonExistentDir = join(tempDir, 'non-existent')

      const result = getPackageManager(nonExistentDir)
      expect(result).toBe('npm') // Should return default
    })
  })

  describe('getPackageManagerInstallCmd', () => {
    it('should return correct install command for detected package manager', async () => {
      await fs.writeFile(join(tempDir, 'yarn.lock'), '')

      const result = getPackageManagerInstallCmd(tempDir)
      expect(result).toBe('yarn')
    })

    it('should return npm install as default', () => {
      const result = getPackageManagerInstallCmd(tempDir)
      expect(result).toBe('npm install')
    })
  })

  describe('getPackageManagerUpdateCmd', () => {
    it('should return correct update command for detected package manager', async () => {
      await fs.writeFile(join(tempDir, 'pnpm-lock.yaml'), '')

      const result = getPackageManagerUpdateCmd(tempDir)
      expect(result).toBe('pnpm update')
    })

    it('should return npm update as default', () => {
      const result = getPackageManagerUpdateCmd(tempDir)
      expect(result).toBe('npm update')
    })
  })

  describe('getRunScriptCmd', () => {
    it('should return correct run script command for detected package manager', async () => {
      await fs.writeFile(join(tempDir, 'package-lock.json'), '{}')

      const result = getRunScriptCmd(tempDir)
      expect(result).toBe('npm install') // This function actually returns install cmd, not run script cmd
    })

    it('should return npm install as default', () => {
      const result = getRunScriptCmd(tempDir)
      expect(result).toBe('npm install')
    })
  })

  describe('isYarn', () => {
    it('should return true when yarn is detected', async () => {
      await fs.writeFile(join(tempDir, 'yarn.lock'), '')

      const result = isYarn(tempDir)
      expect(result).toBe(true)
    })

    it('should return false when other package managers are detected', async () => {
      await fs.writeFile(join(tempDir, 'pnpm-lock.yaml'), '')

      const result = isYarn(tempDir)
      expect(result).toBe(false)
    })

    it('should return false for default npm', () => {
      const result = isYarn(tempDir)
      expect(result).toBe(false)
    })
  })

  describe('runPmUpdate', () => {
    it('should generate correct command and log for yarn', async () => {
      await fs.writeFile(join(tempDir, 'yarn.lock'), '')
      const packages = ['package1', 'package2']

      // Test command generation logic by examining the components
      const updateCmd = getPackageManagerUpdateCmd(tempDir)
      const expectedCmd = [updateCmd, ...packages].join(' ')

      expect(updateCmd).toBe('yarn upgrade')
      expect(expectedCmd).toBe('yarn upgrade package1 package2')

      // We won't test actual execution to avoid system dependencies
      // but can test the function exists and can be called
      expect(typeof runPmUpdate).toBe('function')
    })

    it('should generate correct command for npm when no lock file exists', () => {
      const packages = ['lodash']

      const updateCmd = getPackageManagerUpdateCmd(tempDir)
      const expectedCmd = [updateCmd, ...packages].join(' ')

      expect(updateCmd).toBe('npm update')
      expect(expectedCmd).toBe('npm update lodash')
    })

    it('should handle empty packages array in command generation', () => {
      const updateCmd = getPackageManagerUpdateCmd(tempDir)
      const expectedCmd = [updateCmd].join(' ')

      expect(expectedCmd).toBe('npm update')
    })

    it('should generate correct command for pnpm', async () => {
      await fs.writeFile(join(tempDir, 'pnpm-lock.yaml'), '')
      const packages = ['react', 'vue']

      const updateCmd = getPackageManagerUpdateCmd(tempDir)
      const expectedCmd = [updateCmd, ...packages].join(' ')

      expect(updateCmd).toBe('pnpm update')
      expect(expectedCmd).toBe('pnpm update react vue')
    })
  })

  describe('edge cases', () => {
    it('should handle directory with permission issues', () => {
      // Test with a path that might have permission issues
      const restrictedPath = '/root/restricted'

      const result = getPackageManager(restrictedPath)
      expect(result).toBe('npm') // Should fall back to default
    })

    it('should handle very long package names in command generation', () => {
      const longPackages = [
        'very-long-package-name-that-exceeds-normal-limits-and-contains-many-hyphens-and-words',
        '@scope/another-very-long-scoped-package-name-with-many-segments',
      ]

      const updateCmd = getPackageManagerUpdateCmd(tempDir)
      const expectedCmd = [updateCmd, ...longPackages].join(' ')

      expect(expectedCmd).toContain('npm update')
      expect(expectedCmd).toContain(
        'very-long-package-name-that-exceeds-normal-limits',
      )
      expect(expectedCmd).toContain(
        '@scope/another-very-long-scoped-package-name',
      )
    })

    it('should handle special characters in package names', () => {
      const specialPackages = [
        '@types/node',
        '@babel/core',
        'package-with-hyphens',
        'package_with_underscores',
      ]

      const updateCmd = getPackageManagerUpdateCmd(tempDir)
      const expectedCmd = [updateCmd, ...specialPackages].join(' ')

      expect(expectedCmd).toBe(
        'npm update @types/node @babel/core package-with-hyphens package_with_underscores',
      )
    })

    it('should detect package manager when lock file has unusual content', async () => {
      // Create a yarn.lock with minimal content
      await fs.writeFile(join(tempDir, 'yarn.lock'), '')

      const result = getPackageManager(tempDir)
      expect(result).toBe('yarn')
    })
  })
})
